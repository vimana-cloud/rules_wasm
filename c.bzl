# C-specific rules and macros.

load(":private.bzl", "intermediate_target_name", "kebab_to_snake")
load(":wasm.bzl", "wasm_component")

CWitBindgenInfo = provider(
    "Information relevant to generated C WIT bindings.",
    fields = {
        "include": "Parent directory of generated files.",
    },
)

def _c_wit_bindgen_impl(ctx):
    world = ctx.attr.world or ctx.label.name
    snake_world = kebab_to_snake(world)

    # Output 3 files in a new directory named after the target label's name.
    if ctx.label.package == "":
        out_dir = "{}".format(ctx.label.name)
    else:
        # wit-bindgen hardcodes `#include` directives using the label's package,
        # so if that's non-empty, we need to mirror that structure in the output directory.
        out_dir = "{}/{}".format(ctx.label.name, ctx.label.package)
    source = ctx.actions.declare_file("{}/{}.c".format(out_dir, snake_world))
    header = ctx.actions.declare_file("{}.h".format(snake_world), sibling = source)
    type_object = ctx.actions.declare_file("{}_component_type.o".format(snake_world), sibling = source)
    all_outputs = [source, header, type_object]

    wit_bindgen_arguments = [
        "c",
        ctx.file.src.path,
        "--world",
        world,
        "--out-dir",
        source.dirname,
    ]
    ctx.actions.run(
        inputs = [ctx.file.src],
        outputs = all_outputs,
        executable = ctx.executable._wit_bindgen_bin,
        arguments = wit_bindgen_arguments,
    )

    # This is `out_dir` minus the label's package,
    # which is where clang can later search for the generated header
    # (because the `#include` directive would be prefixed by the label's package).
    include_dir = header.dirname.removesuffix(out_dir) + ctx.label.name

    return [
        DefaultInfo(files = depset(all_outputs)),
        CWitBindgenInfo(include = include_dir),
    ]

c_wit_bindgen = rule(
    implementation = _c_wit_bindgen_impl,
    doc = "Generate C bindings from a WebAssembly Interface (WIT).",
    attrs = {
        "src": attr.label(
            doc = "WIT source file or package.",
            allow_single_file = [".wit"],
        ),
        "world": attr.string(
            doc = "World to generate bindings for. Default is the target name.",
        ),
        "_wit_bindgen_bin": attr.label(
            default = "//:wit-bindgen",
            allow_files = True,
            executable = True,
            cfg = "exec",
        ),
    },
)

def _c_module_impl(ctx):
    world = ctx.attr.world or ctx.label.name
    snake_world = kebab_to_snake(world)

    output = ctx.actions.declare_file("{}.wasm".format(ctx.label.name))
    clang_arguments = [
        "-mexec-model=reactor",
        "-Os",
        "-I",
        ctx.attr.wit[CWitBindgenInfo].include,
        "-o",
        output.path,
    ]
    for src in ctx.files.srcs:
        clang_arguments.append(src.path)
    for wit_src in ctx.files.wit:
        # Only compile C source and object files generated by wit-bindgen,
        # not header files.
        if wit_src.extension == "c" or wit_src.extension == "o":
            clang_arguments.append(wit_src.path)
    ctx.actions.run(
        inputs = ctx.files.srcs + ctx.files.wit,
        outputs = [output],
        executable = ctx.executable._clang_bin,
        arguments = clang_arguments,
    )

    return [DefaultInfo(files = depset([output]))]

# Stopgap solution while figuring out how to set up the WASI SDK as a regular CC toolchain.
c_module = rule(
    implementation = _c_module_impl,
    doc = "Compile a Wasm core module from C source code and generated WIT bindings" +
          " using the WASI SDK.",
    attrs = {
        "srcs": attr.label_list(
            doc = "C source files",
            allow_files = [".c"],
        ),
        "wit": attr.label(
            doc = "Label of a `c_wit_bindgen` rule with relevant C WIT bindings",
            providers = [CWitBindgenInfo],
        ),
        "world": attr.string(
            doc = "World to generate bindings for. Default is the target name.",
        ),
        "_clang_bin": attr.label(
            default = "//:wasi-clang",
            allow_files = True,
            executable = True,
            cfg = "exec",
        ),
    },
)

def c_component(name, srcs, wit, world = None, deps = None):
    """
    Compile a Wasm component given a WIT package (`wit`),
    a set of C source files (`srcs`), and a world name.

    The default for `world` is `name`.
    """
    if world == None:
        world = name
    snake_world = kebab_to_snake(world)
    if deps == None:
        deps = []

    wit_name = intermediate_target_name(name, "wit")
    wit_target = ":" + wit_name
    c_wit_bindgen(
        name = wit_name,
        src = wit,
        world = world,
    )

    # Use `clang` from the WASI SDK to compile the core module.
    core_name = intermediate_target_name(name, "core")
    c_module(
        name = core_name,
        srcs = srcs,
        wit = wit_target,
        world = world,
    )

    wasm_component(
        name = name,
        module = ":" + core_name,
        wit = wit,
        world = world,
    )
